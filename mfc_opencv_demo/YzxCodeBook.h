
#ifndef __YZXCODEBOOK_H__
#define __YZXCODEBOOK_H__
#include "opencv2/core/core.hpp"
#include "opencv2/video/background_segm.hpp"
#include "opencv2/imgproc/imgproc_c.h"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/legacy/legacy.hpp"

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <cxcore.h>

using namespace std;
using namespace cv;
#define  CHANNELS 3
////For connected components:
//const int CVCONTOUR_APPROX_LEVEL = 2;   // Approx.threshold - the bigger it is, the simpler is the boundary
//const int CVCLOSE_ITR = 1;				// How many iterations of erosion and/or dilation there should be
////#define CVPERIMSCALE 4			// image (width+height)/PERIMSCALE.  If contour length < this, delete that contour
//
////For learning background
//const double COLORDIST_THREAD = 0.0;
//Just some convenience macros
#define CV_CVX_WHITE	CV_RGB(0xff,0xff,0xff)
#define CV_CVX_BLACK	CV_RGB(0x00,0x00,0x00)
typedef struct code_word
{
	float myRGB[CHANNELS];
	uchar learnHigh[CHANNELS];// High side threshold for learning  
	uchar learnLow[CHANNELS];// Low side threshold for learning  
	uchar max[CHANNELS]; //// High side of box boundary
	uchar min[CHANNELS];  //// Low side of box boundary
	int frequency;
	int t_last_update;  // This is book keeping to allow us to kill stale entries
	int stale;// max negative run (biggest period of inactivity)
} code_element;

typedef struct code_book
{
	code_element **cb;
	int numEntries;
	int t;
}codeBook;

class YzxCodeBook
{
public:
	YzxCodeBook(void);
	~YzxCodeBook(void);
	double getcolordist(uchar* pRGBx, float* pRGBv);
	int cvupdateCodeBook(uchar *p,uchar *pRGB, codeBook &c, unsigned *cbBounds, int numChannels = 3);
	uchar cvbackgroundDiff(uchar *p,uchar* pRGB,  codeBook &c, int numChannels, int *minMod, int *maxMod);
	int cvclearStaleEntries(codeBook &c);
	int cvcountSegmentation(codeBook *c, Mat& I, Mat& raw, int numChannels, int *minMod, int *maxMod);
	void cvconnectedComponents(Mat& mask, int poly1_hull0 = 1, float perimScale = 4.0, int *num = NULL, cv::Rect *bbs = NULL, cv::Point2i *centers = NULL);
	void cvconnectedComponents(IplImage *mask, int poly1_hull0 = 1, float perimScale = 4.0 , int *num = NULL, CvRect *bbs = NULL, CvPoint *centers = NULL);
	void cvconnectedComponents2(Mat& mask);
	void cvconnectedComponents3(Mat& mask);

	//For connected components:
	int CVCONTOUR_APPROX_LEVEL;   // Approx.threshold - the bigger it is, the simpler is the boundary
	int CVCLOSE_ITR;				// How many iterations of erosion and/or dilation there should be
	//#define CVPERIMSCALE 4			// image (width+height)/PERIMSCALE.  If contour length < this, delete that contour

	//For learning background
	double COLORDIST_THREAD;

	//! per-pixel blink detection map ('Z(x)')
	cv::Mat m_oBlinksFrame;

	//! the foreground mask generated by the method at [t-1] (without post-proc, used for blinking px detection)
	cv::Mat m_oLastRawFGMask;

	//! the foreground mask generated by the method at [t-1]
	cv::Mat m_oLastFGMask;
	//! pre-allocated CV_8UC1 matrices used to speed up morph ops
	cv::Mat m_oFGMask_PreFlood;
	cv::Mat m_oFGMask_FloodedHoles;
	cv::Mat m_oLastFGMask_dilated;
	cv::Mat m_oLastFGMask_dilated_inverted;
	cv::Mat m_oCurrRawFGBlinkMask;
	cv::Mat m_oLastRawFGBlinkMask;
	void modifyMask(cv::Mat& oCurrFGMask);
	void initialize(const cv::Mat& oInitImg);
	cv::Size m_oImgSize;
};

#endif

